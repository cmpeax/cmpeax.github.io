---
title: 浅谈指令重排
date: 2022-03-08 10:30:39
categories: 
- 操作系统知识
tags:
- 后端
- Golang
- 操作系统
---

> Go官方文档专门介绍Go的内存模型，它描述了并发环境下多goroutine读相同变量时，变量的可见性条件。 https://go.dev/ref/mem


由于CPU指令重排和多级Cache的存在，保证多核访问同一个变量变得非常复杂。编程语言需要一个规范来明确多线程同时访问同一个变量的可行性和顺序，这个规范被叫做内存模型。

## happens-before
* 在一个goroutine内部，程序的执行顺序和它们代码指定的顺序是一样的。即使编译器或者CPU重排了读写顺序，从行为上来看，也和代码指定的顺序一样。

原因： CPU为了提高效率会对指令进行重排序，但是指令重排会遵守As-if-serial的规则，即保证重排序后的结果和程序代码本身的应有结果是一致的，这个情况在单线程上不会存在问题，但在多线程上，这个规则则会失效。



Go 内存模型通过 happens-before 定义两个事件（读、写 action）的顺序：如果事件 e1 happens before 事件 e2，那么，我们就可以说事件 e2 在事件 e1 之后发生（happens after）。如果 e1 不是 happens before e2， 同时也不 happens after e2，那么，我们就可以说事件 e1 和 e2 是同时发生的。
（要么前，要么后，否则认为同时）

![show.png](https://s2.loli.net/2022/03/08/TVM1k4gCHeuOzpE.png)

三个Go语言中和内存模型有关的知识点
* 在 Go 语言中，对变量进行零值的初始化就是一个写操作。
* 如果对超过机器 word（64bit、32bit 或者其它）大小的值进行读写，那么，就可以看作是对拆成 word 大小的几个读写无序进行。
* Go 并不提供直接的 CPU 屏障（CPU fence）来提示编译器或者 CPU 保证顺序性，而是使用不同架构的内存屏障指令来实现统一的并发原语。

参考文献: https://blog.csdn.net/Zerore/article/details/120321985